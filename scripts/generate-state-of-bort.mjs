#!/usr/bin/env node
import fs from 'fs'
import path from 'path'
import { spawnSync } from 'child_process'

const WORKSPACE = '/root/.openclaw/workspace'
const PROJECT_SOURCE = path.join(WORKSPACE, 'project_source')
const STATE_PATH = path.join(PROJECT_SOURCE, 'STATE_OF_BORT.md')
const TEMPLATES_PATH = path.join(PROJECT_SOURCE, 'PROMPT_TEMPLATES.md')

function run(cmd, args) {
  const r = spawnSync(cmd, args, { encoding: 'utf8' })
  return {
    ok: (r.status ?? 1) === 0,
    out: (r.stdout || '').trim(),
    err: (r.stderr || '').trim(),
  }
}

function nowPhoenixStamp() {
  const dtf = new Intl.DateTimeFormat('en-US', {
    timeZone: 'America/Phoenix',
    month: 'short',
    day: '2-digit',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  })
  return dtf.format(new Date()) + ' (America/Phoenix)'
}

function listDirNames(p) {
  try {
    return fs.readdirSync(p, { withFileTypes: true }).filter((d) => d.isDirectory()).map((d) => d.name).sort()
  } catch {
    return []
  }
}

function countFiles(p) {
  let n = 0
  function walk(cur) {
    let entries = []
    try { entries = fs.readdirSync(cur, { withFileTypes: true }) } catch { return }
    for (const e of entries) {
      const full = path.join(cur, e.name)
      if (e.isDirectory()) walk(full)
      else n += 1
    }
  }
  walk(p)
  return n
}

function parseJsonSafe(s) {
  try { return JSON.parse(s) } catch { return null }
}

function main() {
  fs.mkdirSync(PROJECT_SOURCE, { recursive: true })

  const modelStatus = run('openclaw', ['models', 'status', '--json'])
  const modelJson = parseJsonSafe(modelStatus.out) || {}

  const cron = run('openclaw', ['cron', 'list', '--json'])
  const cronJson = parseJsonSafe(cron.out) || { jobs: [] }

  const skills = run('openclaw', ['skills', 'list', '--json'])
  const skillsJson = parseJsonSafe(skills.out)

  const workspaceSkills = listDirNames(path.join(WORKSPACE, 'skills'))
  const topDirs = listDirNames(WORKSPACE)

  const jobs = Array.isArray(cronJson.jobs) ? cronJson.jobs : []
  const allowedModels = Array.isArray(modelJson.allowed) ? modelJson.allowed : []
  const fallbacks = Array.isArray(modelJson.fallbacks) ? modelJson.fallbacks : []

  const skillLines = []
  if (skillsJson && Array.isArray(skillsJson.skills)) {
    for (const s of skillsJson.skills.slice(0, 30)) {
      skillLines.push(`- ${s.name || s.id || 'unknown'}`)
    }
  } else if (workspaceSkills.length) {
    for (const s of workspaceSkills) skillLines.push(`- ${s}`)
  } else {
    skillLines.push('- (none detected)')
  }

  const jobLines = jobs.length
    ? jobs.map((j) => `- ${j.name || j.id} (${j.schedule?.kind || 'unknown'}: ${j.schedule?.expr || 'n/a'} ${j.schedule?.tz || ''})`).join('\n')
    : '- (none)'

  const content = [
    '# STATE_OF_BORT.md',
    '',
    `Generated: ${nowPhoenixStamp()}`,
    '',
    '## Runtime snapshot',
    `- model_default: ${modelJson.defaultModel || 'unknown'}`,
    `- model_resolved_default: ${modelJson.resolvedDefault || 'unknown'}`,
    `- model_fallbacks: ${fallbacks.length ? fallbacks.join(', ') : '(none)'}`,
    `- allowed_model_count: ${allowedModels.length}`,
    `- cron_job_count: ${jobs.length}`,
    `- workspace_top_level_dirs: ${topDirs.length}`,
    `- workspace_file_count_recursive: ${countFiles(WORKSPACE)}`,
    '',
    '## Allowed model IDs',
    ...(allowedModels.length ? allowedModels.map((m) => `- ${m}`) : ['- (none detected)']),
    '',
    '## Installed / available skills',
    ...skillLines,
    '',
    '## Scheduled jobs (cron)',
    ...jobLines.split('\n'),
    '',
    '## Export artifacts',
    '- project_source/EXPORT_LATEST.md',
    '- dist/bort_source_bundle.tgz',
    '',
    '## Notes',
    '- This file is regenerated by scripts/generate-state-of-bort.mjs.',
    '- It is intended as an external handoff snapshot for ChatGPT projects and audits.',
    '',
  ].join('\n')

  const templates = [
    '# PROMPT_TEMPLATES.md',
    '',
    '## 1) Quick execution prompt',
    'Goal: <one sentence outcome>',
    'Context: <relevant state/files/links>',
    'Constraints: <what is allowed / forbidden>',
    'Inputs: <exact paths/data>',
    'Output format: <bullets/json/diff>',
    'Definition of Done: <verifiable checks>',
    '',
    '## 2) Read-only audit prompt',
    'Authority: READ-ONLY. No edits, no restarts, no external sends.',
    'Goal: <what to verify>',
    'Checks: <exact commands/files>',
    'Output: raw command output + concise findings.',
    'Done when: <explicit checks pass/fail>',
    '',
    '## 3) Safe change prompt (with validation)',
    'Authority: MAY edit workspace files only.',
    'Goal: <target end-state>',
    'Rules: no /usr/lib changes unless approved; no destructive ops.',
    'Implementation: <files to edit>',
    'Actions: include policy tags when applicable, e.g. cmd:<exact command> and skill:<skill-id>.',
    'Validation: run <tests/commands>; include exact output.',
    'Deliverable: changed paths + minimal diff + rollback note.',
    '',
    '## 4) Incident response prompt',
    'Goal: restore service safely.',
    'Priority: correctness over speed.',
    'Constraints: ask before restart/delete; keep evidence.',
    'Steps: diagnose -> isolate root cause -> propose fix -> apply (if approved) -> verify.',
    'Output: timeline, root cause, fix, prevention items.',
    '',
  ].join('\n')

  fs.writeFileSync(STATE_PATH, content, 'utf8')
  fs.writeFileSync(TEMPLATES_PATH, templates + '\n', 'utf8')
}

main()
